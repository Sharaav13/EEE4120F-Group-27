% =========================================================================
% Practical 1: 2D Convolution Analysis
% =========================================================================
%
% GROUP NUMBER: 27
%
% MEMBERS:
%   - Member 1 Max Mendelow, MNDMAX003
%   - Member 2 Sharaav Dhebideen, DHBSHA001


%% ========================================================================
%  PART 1: Manual 2D Convolution Implementation
%  ========================================================================
%
% REQUIREMENT: You may NOT use built-in convolution functions (conv2, imfilter, etc.)

% TODO: Implement manual 2D convolution using Sobel Operator(Gx and Gy)
% output - Convolved image result (grayscale)
function [G, exetime] = my_conv2(image, Kx, Ky) %Add necessary input arguments
    
    start = tic; % start timer

    % Importing the image
    I_raw  = im2double(im2gray(image)); % Each pixel is assigned an intensity value between 0 and 1.
    [m, n] = size(I_raw);

    % Padding image
    I = padarray(I_raw, [1, 1]);
    
    % Performing the 2D convolution
    G = zeros(m, n); % Edge-detection matrix with gradient magnitudes.
    for x = 1:m
        for y = 1:n
            p1 = I(x, y);    p2 = I(x, y+1); % Using offsets to find all pixels in the neighbourhood grid
            p3 = I(x, y+2);  p4 = I(x+1, y);
            p6 = I(x+1, y+2);    p7 = I(x+2, y);
            p8 = I(x+2, y+1);    p9 = I(x+2, y+2);

            vert_gradient = abs((p1*Ky(1, 1) + p2*Ky(1, 2) + p3*Ky(1, 3)) + (p7*Ky(3, 1) + p8*Ky(3, 2) + p9*Ky(3, 3)));
            horz_gradient = abs((p3*Kx(1, 3) + p6*Kx(2, 3) + p9*Kx(3, 3)) + (p1*Kx(1, 1) + p4*Kx(2, 1) + p7*Kx(3, 1)));

            G(x, y) =  vert_gradient + horz_gradient; % Approximate gradient magnitude formula
        end
    end

    exetime = toc(start); % end timer
end

%% ========================================================================
%  PART 2: Built-in 2D Convolution Implementation
%  ========================================================================
%   
% REQUIREMENT: You MUST use the built-in conv2 function

% TODO: Use conv2 to perform 2D convolution
% output - Convolved image result (grayscale)
function [G, exetime] = inbuilt_conv2(image, Kx, Ky) %Add necessary input arguments
    
    start = tic; % start timer

    % Importing the image
    I  = im2double(im2gray(image)); % Each pixel is assigned an intensity value between 0 and 1.
    
    % Performing the 2D convolution
    Gx = conv2(I, Kx, 'same');
    Gy = conv2(I, Ky, 'same');
    G = sqrt(Gx.^2 + Gy.^2);

    exetime = toc(start); % end timer
end


%% ========================================================================
%  PART 3: Testing and Analysis
%  ========================================================================
%
% Compare the performance of manual 2D convolution (my_conv2) with MATLAB's
% built-in conv2 function (inbuilt_conv2).

function run_analysisf()
    % TODO1:
    % Load all the sample images from the 'sample_images' folder
    i1 = imread('sample_images/image_128x128.png');
    i2 = imread('sample_images/image_256x256.png');
    i3 = imread('sample_images/image_512x512.png');
    i4 = imread('sample_images/image_1024x1024.png');
    i5 = imread('sample_images/image_2048x2048.png');
    images = {i1, i2, i3, i4, i5};
        
    % TODO2:
    % Define edge detection kernels (Sobel kernel)
    Kx = [-1 0 1; -2 0 2; -1 0 1];
    Ky = [1 2 1; 0 0 0; -1 -2 -1];

    % TODO3:
    % For each image, perform the following:
    %   a. Measure execution time of my_conv2
    %   b. Measure execution time of inbuilt_conv2
    %   c. Compute speedup ratio
    %   d. Verify output correctness (compare results)
    %   e. Store results (image name, time_manual, time_builtin, speedup)
    %   f. Plot and compare results
    %   g. Visualise the edge detection results(Optional)
    
    n = 1000; % Number of times to repeat the 2D Convolution for a single image.

    % Assigning the square image pixel-length as each image name
    image_names = [128, 256, 512, 1024, 2048];
    
    % Arrays to store benchmarking results per image
    time_manual = zeros(1,5);
    time_builtin = zeros(1,5);
    speedup = zeros(1,5);
    accuracy = zeros(1,5);

    % Celled arrays to store edge-detection matrices per image
    edm_manual = cell(5); 
    edm_builtin = cell(5);
    
    % Collecting and storing results
    for i = 1:5
        sum_t_manual = 0;
        sum_t_builtin = 0;
        for r = 1:n  % Repeat the 
            [edm_manual{i}, t_manual] = my_conv2(images{i}, Kx, Ky);
            [edm_builtin{i}, t_builtin] = inbuilt_conv2(images{i}, Kx, Ky);
            sum_t_manual = sum_t_manual + t_manual;
            sum_t_builtin = sum_t_builtin + t_builtin;
        end
        time_manual(i) = sum_t_manual/n;
        time_builtin(i) = sum_t_builtin/n;
        speedup(i) = time_manual(i)/time_builtin(i);
        diff_pxli = abs(edm_manual{i} - edm_builtin{i});
        accuracy(i) = mean(diff_pxli(:));
    end
    
    % Display results
    disp("time_manual")
    disp(time_manual)
    disp("time_builtin")
    disp(time_builtin)
    disp("speedup")
    disp(speedup)
    disp("accuracy")
    disp(accuracy)

    % Plots for execution time per image
    figure;
    plot(image_names, time_manual, '.-','MarkerSize', 16, "LineStyle","-","Color","r","LineWidth",1.5);
    xlabel("Square Image Length (pixels)");
    ylabel("Execution Time (s)");
    title("Execution Time versus Image Sizes for 2D Convolution Functions");
    grid on;
    hold on;
    plot(image_names, time_builtin, '.-','MarkerSize',16 , "LineStyle","-","Color","b","LineWidth",1.5);
    hold off;
    
    % Plot for Speed Up/Slow Down
    figure;
    plot(image_names, speedup, '.-','MarkerSize', 16, "LineStyle","-","Color","k","LineWidth",2);
    xlabel("Square Image Length (pixels)");
    ylabel("Speed Up/Slow Down");
    title("Speed Up/Slow Down versus Image Sizes for 2D Convolution Functions");
    grid on;
    
    % Plot for Deviation in Pixel-intensity
    figure;
    plot(image_names, accuracy, '.-','MarkerSize', 16, "LineStyle","-","Color","k","LineWidth",2);
    xlabel("Square Image Length (pixels)");
    ylabel("Absolute Average Difference in Pixel-intensity");
    title("Deviation of Pixel-intensity in the Manual results from the Built-in results");
    grid on;
        
    % Visualisation of resulting Edge-detection images
    for e = 1:5
        resolution = string(image_names(e));
        figname = "Comparision of " + resolution + " x " + resolution + " px Edge-detection Images";
        Ia = mat2gray(edm_manual{e});
        Ib = mat2gray(edm_builtin{e});

        figure
        subplot(1,2,1), imshow(Ia), title("(a) Manual result");
        subplot(1,2,2), imshow(Ib), title("(b) Built-in result");
        sgtitle(figname);
    end 
end

run_analysisf();